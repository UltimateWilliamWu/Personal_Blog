---
tags:
  - Java
---
# 1. 面试问题
## 4.1 public、protected、default、private
- default是默认的，什么都不写，在同⼀个包内是可见的，不使⽤任何修饰符。
- public能⽤来修饰类，在⼀个java源⽂件中只能有⼀个类被声明为public，⽽且⼀旦有⼀个类为public，那这个java源⽂件的⽂件名就必须要和这个被public所修饰的类的类名相同，否则编译不能通过。public⽤来修饰类中成员（变量和⽅法），被public所修饰的成员可以在任何类中都能被访问到。
- protected是受保护的，受到该类所在的包所保护，被protected所修饰的成员会被位于同⼀package中的所有类访问到。同时，被protected所修饰的成员也能被该类的所有⼦类继承下来。
- private，private是私有的，即只能在当前类中被访问到，它的作⽤域最⼩。![[Pasted image 20240417174829.png|725]]
## 4.2 final、finally、finalize关键字
- final就是不可变的意思，可以修饰变量、⽅法和类。修饰变量时，这个变量必须初始化，所以也称为常量。
- finally是异常处理的⼀部分，只能⽤在try/catch中，并且附带⼀个语句块表⽰这段语句⼀定会被执⾏，⽆论是否抛出异常。
- finalize是java.lang.Object中的⽅法，也就是每⼀个对象都有这个⽅法，⼀个对象的finalize⽅法只会调⽤⼀次，调⽤了不⼀定被回收，因为只有对象被回收的时候才会被回收，就会导致前⾯调⽤，后⾯回收的时候出现问题，不推荐使⽤。
## 4.3 static关键字
>这就要提到new对象，只有new对象之后，数据存储空间才会被分配，⽅法才能供外界调⽤。但是当没有创建对象的时候也想要调⽤⽅法或者就是想为特定分配存储空间的时候，就需要⽤static。所以有了static，成员变量或者⽅法就可以在没有所属类的时候被访问了。static创建的变量、方法等是存储在方法区（Method Area）中，也称为静态存储区域。

>[!note] static 成员变量、成员方法同理
>```Java
>public class Student{
>	//类变量
>	static String Student;
>	//成员变量 实例变量
>	int age; //无static修饰，专属于每个对象
>}
>```
>- 类变量
>	有static修饰，属于类，在计算机中只有一份，会被类的全部对象共享
>- 实例变量
>	无static修饰，专属于每个对象
## 4.4 This关键字
this是一个变量可用于方法中，来拿到当前对象。哪个对象调用方法就指向哪个对象
>[!FAQ] this 的作用？
>解决对象成员变量名与类中方法的形参一致时所导致的访问冲突问题
>区分成员变量和局部变量
## 4.5 == 和equals 的区别
" == "在基本数据类型：值内容, 引用类型时：地址  
含有 equals 重写：值内容 ， equals不重写：地址
## 4.6 String 和 new String()的区别
双引号创建的字符串常量是在编译期间就已经确定了，通常处于字符串常量池中。而使用new String()创建的字符串对象是存储在堆内存中的。
# 2. JDK JRE JVM
- JDK：英文全称 Java Development Kit，是Java的开发工具包 JDK是提供给Java开发人员使用的，其中包含了Java的开发工具和JRE。其中的开发工具包括：编译工具（javac.exe）打包工具（jar.exe）等。通俗的说就是开发用的。
- JRE：英文全称 Java Runtime Environment，是Java运行环境 JRE包括Java虚拟机 (JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。通俗的说就是运行用的。
- JVM：英文全称 Java Virtual Machine），是java虚拟机。 它只认识.class为后缀的文件，它能将class文件中的字节码指令进行识别并调用操作系统向上的API完成动作。JVM是java能够跨平台的核心机制。通俗的说就是跨平台用的，就是把我们写的代码，转换成class文件用的。
- ![[Pasted image 20240326152907.png]]
# 4. 字面量 变量 常量
```Java
	int a; //变量
	const int b = 10; //b为常量，10为字面量
	string str = “hello world！”; // str 为变量，hello world！为字面量
```
- 字面量（literal）：是用于表达源代码中一个固定值的表示法（notation）
- 变量：有些数据在程序运行中可以变化或者被赋值，这称为变量。
	- 变量的特点：
		- -变量必须要先声明
		- 变量类型必须和存储数据类型一致
		- 变量有访问范围
		- 变量可以没有初值，但使用时必须要有值
		- 变量不可重复定义
		- 常量：有些数据可以在程序使用之前预先设定并在整个运行过程中没有变化，这称为常量。使用static final修饰的变量。 
# 3. 标识符/运算符
>在Java中，标识符是用来标识变量、方法、类、包或其他用户定义的命名实体的名称。
### 3.1 标识符
规则：
- 标识符可以包含字母（大小写）、数字和下划线（_）以及美元符号($)。但标识符不能以数字开头。
- 标识符不能包含空格或其他特殊字符，如@、#、!等。
- 标识符不能是Java的关键字（如class、int、if等），因为关键字已被用于Java的语法和控制结构。
- Java标识符是大小写敏感的，即大写字母和小写字母被视为不同的标识符。
规范：
- 标识符应该具有描述性，能够清晰地表达它所代表的对象的含义。
- 标识符应该使用有意义的单词或缩写，并且尽量避免使用无意义的字符组合。
- 标识符的命名应该符合命名约定，以便于其他程序员理解和维护代码。在Java中，通常采用驼峰命名法（CamelCase）来命名标识符，即除了第一个单词外，后续的单词首字母大写，如myVariableName。
- 对于包名、类名和接口名，通常使用首字母大写的驼峰命名法，如MyClass。
- 对于变量名和方法名，通常使用首字母小写的驼峰命名法，如myMethodName。
- 对于常量名，通常使用全部大写字母，单词之间用下划线分隔，如MAX_VALUE。
- 尽量避免使用单个字符的标识符，除非是在循环索引或临时变量等特殊情况下。
### 3.2 运算符
#### 1 . 逻辑运算符
- ![[Pasted image 20240324182836.png|650]]
#### 2. 运算符优先级
- ![[Pasted image 20240324182911.png|700]]
# 5. 数据类型/类型转换
## 5.1 基本数据类型
![[Pasted image 20240324160502.png|775]]
## 5.2 引用数据类型
### 1）类（Class）：
- 类是Java中最基本的引用数据类型，它是用户自定义的一种数据类型，可以包含属性（字段）和方法。
- 代码块：
	- 静态代码块：
		- 格式：static{}
		- 特点：类加载时自动执行，由于类只加载一次，所以静态代码块也只执行一次
		- 作用：完成类的初始化 例如：对类变量的初始化赋值
	- 实例代码块
		- 格式：{}
		- 特点：每次创建对象时，执行实例代码块，并且先于构造器的执行
		- 作用：同静态代码块，对对象的初始化 例如：对实例变量进行初始化赋值
#### 标准库类
- 随机数（Random）
	- Random.nextInt(int bound) 是 Java 中 Random 类的一个方法，用于生成一个指定范围内的随机整数。
	- 参数 bound：指定生成随机数的范围，生成的随机数将在 0（包含）和 bound（不包含）之间。换句话说，生成的随机数的范围是 [0, bound)，即闭区间0到开区间 bound。
	- 返回值：返回一个 int 类型的随机整数，范围在 0（包含）和 bound（不包含）之间。
- ArrayList 集合
	- Arraylist是集合中常用的一种。ArrayList是泛型类可以约束存储的数据类型
>![[Pasted image 20240404154009.png|650]]
#### 内部类 
##### 1.成员内部类
```Java
puiblic class Outer{
	//成员内部类
	public class Inner{
	
	}
}
```
场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类
##### 2.静态内部类
```Java
public class Outer{
	public static class Inner{
	}
}
```
可以直接访问外部类的静态成员，不可以直接访问外部类的实例成员
##### 3.局部内部类
##### ==4.匿名内部类==
>[!important] 定义
>一种特殊的局部内部类，所谓匿名是指不需要为这个内部类声明名字
>- 匿名内部类本质是一个子类，并且会立即创建出一个子类对象

>[!note] 使用场景
>作为一个参数传输给方法
>```Java
>new Animal(){
>	public  void cry(){
>	}
>};
>```

#### 工具类
- 作用：实例方法需要创建对象来调用，若对象只是为了调用方法，不需要实例化浪费内存空间。
#### 抽象类
- abstract关键字可修饰类和成员方法 因此分为抽象类和抽象方法
>[!note] 抽象类和抽象方法特点
>1.抽象方法不能有方法体
>2.抽象类中不一定有抽象方法，有抽象方法的类一定时抽象类
>3.抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现
>4.一个类继承抽象类，必须完全重写所有抽象方法，否则这个类也必须定义为抽象类
#### 枚举类
```Java
public enum A{
	X,Y,Z;
}
```
- 枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象
- 枚举类的构造器都是私有的，枚举类不能对外创建对象
- 枚举类都是最终类，不可以被继承
- 
#### 局部类

### 2）接口（Interface）：
- 接口是一种引用数据类型，它定义了一组方法的集合，但是没有方法的实现。其他类可以实现接口，并提供接口中定义的方法的具体实现。
- 接口不能用于创建对象，接口是用来被类实现的，实现接口的类被称之为实现类
- 一个类可以实现多个接口，一个实现类必须重写完全部接口的全部抽象方法否则该实现类被定义为抽象类
>[!note] 接口的好处
>- 弥补了类单继承的不足
>- 让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现

>[!warning] 接口的注意事项
>- 一个接口继承/实现多个接口，若多个接口中存在方法名冲突，则此时不支持多继承
>- 一个类继承父类，又实现了接口，父类中和接口中有同名默认方法，此时优先使用父类
>- 一个类实现多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可

### 3）数组（Array）：
- 数组是一种引用数据类型，它可以存储相同类型的多个数据元素。在Java中，数组是对象，因此数组变量存储的是对数组对象的引用。数组变量名中存储的是数组在内存中的地址，因此数组是一种引用数据类型。
	- 数组元素访问指的是在数组中获取或设置特定索引位置的元素的过程。
	- 静态初始化数组
		-  开始知道要存入哪些元素值的业务场景
	- 动态初始化数组
		- 开始不确定元素具体值，只知道元素个数的业务场景
		- ![[Pasted image 20240324161546.png|500]]
		- 注意：char默认值是Unicode编码的空字符（\u0000）
### 4）枚举（Enum）：
- 枚举是一种引用数据类型，它是一组有限的命名常量的集合。在Java中，枚举类型是通过关键字enum定义的。
### 5）注解（Annotation）：
- 注解也是一种引用数据类型，它用于为程序元素（如类、方法、变量等）提供元数据信息。注解是通过@符号来标识的。
### 6）包装类（WrapperClass）：
- 包装类是一种引用数据类型，它将基本数据类型（如int、double等）封装成对象。Java提供了一组包装类来实现基本数据类型和引用数据类型之间的转换和操作，例如Integer、Double等。
## 5.3 类型转换
### 1 自动类型转换：
- 表达式的结果类型以表达式中最高类型所决定
	- 在表达式中，byte,short,char 都是直接转换为int类型参与运算的
	- ![[Pasted image 20240324182720.png|650]]
### 2 强制类型转换：
- 强制类型转换是把变量从一种类型转换为另一种数据类型。
	- 大范围类型转换为小范围类型时会造成溢出，可能造成数据丢失。
# 6. Java执行顺序及原理
## Java执行顺序
1. 顺序结构
	1. 自上而下的执行结构
2. 分支结构
	1. if/switch
	2. ![[Pasted image 20240324183108.png|176]]
3. 循环结构
	1. do-while
		![[Pasted image 20240324183128.png|325]]
	2. for
		 ![[ Pasted image 20240324183232.png|400]]
	3. while
		 ![[Pasted image 20240324183247.png|300]]
	4. 总结
		- for循环通常用于已知循环次数的情况，而while循环用于循环次数不确定的情况。
		- for循环提供了初始化、条件和迭代三个控制部分，适合简单的迭代控制，而while循环只有一个条件控制部分，更适合灵活的循环条件。
		- 在语法上，for循环的结构更紧凑，而while循环的结构更灵活，适用于更复杂的控制结构。

## Java执行原理
1. 编写代码
	开发人员使用文本编辑器或集成开发环境（IDE）编写 Java 代码。
6. 编译代码
	Java 代码经过编译器（例如 javac）处理，将源代码编译成字节码文件（.class 文件）。字节码是一种与平台无关的中间代码，它被 JVM（Java 虚拟机）所理解。
7. 加载类文件
	Java 虚拟机（JVM）负责加载字节码文件，并将其转换成机器码。在加载类文件时，会执行类加载器（ClassLoader）的工作，ClassLoader 会按照特定的顺序（如双亲委派模型）加载类文件，最终形成类的层次结构。
8. 执行程序
	一旦类文件被加载到 JVM 中，JVM 就会执行字节码指令，逐行解释并执行程序。JVM 提供了运行时环境，包括内存管理、垃圾回收、线程管理等功能，以确保程序可以正确执行。
9. 运行时优化
	JVM 在运行时会进行一些优化操作，例如即时编译（JIT）等，以提高程序的性能。
10. 执行结束
	程序执行完毕后，JVM 负责释放资源，并将程序的执行结果返回给用户。
### 9.1 Java内存分配
- 方法区
	字节码文件加载进方法区
- 栈
	函数或者方法放入栈中运行
- 堆
	new新对象在新的内存空间中开辟出的空间地址
- 本地方法栈
- 寄存器
# 7. Java方法
- 方法是一种语法结构，将一段代码封装成一个小功能，以便复用。
- 方法修饰符
	- 有 public static protected
- 返回值类型
	- 当方法的返回值类型不为空值时，方法内部必须要有对应的return语句返回对应的数值类型。
- 方法名
	- 顾名思义，定义方法的作用，方便程序员对了解该段程序的作用
- 形参列表
	- 形参列表可以有多种，且必须用”，“隔开，并且不能给初始化值。
- 方法在计算机中的执行原理
	- 方法被调用的时候，是进入到栈内存中运行的
## 7.1 方法重载
- 方法重载是指在同一个类中可以定义多个方法，方法名相同但参数列表不同。方法重载可以根据不同的参数类型、个数或顺序来调用不同的方法，提高了代码的灵活性和可复用性。方法重载使得程序更易于理解和使用，同时提高了代码的可读性。
## 7.2 Java参数传递
- 值传递：传输实参给方法的形参时，传输的是实参变量中存储的值的副本。
### 1）引用类型的值传递
- 引用类型传递的值是存储数据的地址
```Java
public static void main(String[] args){
	int[] arrs=new int[]{10,20,30};
	change(arrs);
	System.out.println("main:"+arrs[1]);//此时输出的是222 因为这是引用类型的值传递
}
public static void change(int[] arrs){ //这里的arrs形参实际上传递是数组地址
	System.out.println("方法一内："+arrs[1]);
	arrs[1]=222;
	System.out.println("方法二内："+arrs[1]); //此时这里输出的是222
}
```
### 2）基本类型的值传递
- 基本类型传递的值是存储数据的值
```Java
public static void main(String[] args){
	int a=10;
	change(a);
	System.out.println("main:"+a);//此时输出的是10
}
public static void change(int a){ 
	System.out.println("方法一内："+a);//此时这里输出的是10
	arrs[1]=20;
	System.out.println("方法二内："+a); //此时这里输出的是20
}
```
## 7.3 泛型方法
```Java
public static <T> void test(T t){
}
public static void go(ArraryList<? extends Car> cars){
}
```
- 通配符？在使用泛型时可以代表一切类型
# 8. 基本算法
## 11.1 求最大公约数
- 欧几里得算法（辗转相除法）
```Java
public static int measure(int x,int y){  //求最大公约数
    int z = y;  
    if(x==0||y==0){  
        return 0;  
    }  
    while(x%y!=0)  
    {  
        z = x%y;  
        x = y;  
        y = z;  
    }  
    return z;  
}
```
- 其时间复杂度为 O(log(min(a, b)))，其中 a 和 b 是输入的两个数，这意味着算法的执行时间与输入的数的大小无关，而是与它们的位数相关。
## 11.2 找素数
```Java
public static void isPrime1(int x){
        boolean flag;
        int i=0;
        int j=0;
        flag=true;
        for(j=2;j<=Math.sqrt(x);j++){ //循环次数最少 效率最高
            if(x%j==0){
                flag=false;
                break;
            }
        }
        if(j>Math.sqrt(x)){
            System.out.println("是素数");
        }else{
            System.out.println("不是素数");
        }
    }
    public static void main(String[] args) {
        isPrime1(17);
    }
```
# 9. 面向对象
## 9.1面向对象编程
>[!FAQ] 面向对象编程和面向过程编程的区别
>简述：
>- 面向对象编程将问题看作是由各种对象之间的交互来解决的。重点在于将问题划分为各种对象，每个对象都有自己的属性和行为，并且可以通过消息传递来进行交互。
>- 面向过程编程将问题看作是由一系列的步骤（过程）来解决的。重点在于按照执行顺序进行步骤的排列，每个步骤都是对数据的操作。
>1. 面向对象
>- 面向对象编程通过定义类和对象来组织代码。类是对现实世界中的实体的抽象，而对象是类的实例，具有特定的属性和行为。
>- 面向对象编程提倡通过继承、封装和多态等特性来实现代码的重用，可以更灵活地组合和扩展已有的代码。
>- 面向对象编程通常具有更好的维护性，因为它更容易理解和修改。对象之间的关系清晰明了，修改一个对象的行为通常不会影响其他对象。
>	- 面向对象编程优点：编程更为直观，更符合人们的正常思维
>	- 对象是一种特殊的数据结构
>	- 对象可以通过类new
>1. 面向过程
>- 面向过程编程通过定义函数和数据结构来组织代码。函数是对操作的抽象，数据结构用于存储和组织数据。
>- 面向过程编程通常通过函数的调用来实现代码的重用，但是相对于面向对象编程来说，重用性较差。
>- 面向过程编程可能会造成代码的耦合度较高，修改一个步骤可能会影响整个程序的运行。

>[!note] Java垃圾回收机制
>在Java中，当堆内存中的对象没有任何指针指向时，会被视为“垃圾”，由JVM回收垃圾内存。
## 9.2 构造器
>构造器特点：
>- 创建对象时，对象会调用构造器
> 构造器使用场景：
>- 创建对象时，同时完成对对象成员变量的初始化赋值
## 9.3 封装、多态、继承
### 9.3.1 封装
>[!note] 封装
>用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理这些数据的方法，设计到一个对象中去。

>[!FAQ] 封装设计规范？
>合理隐藏、合理暴露
>```Java
>public class Student{
>	private double score;
>	public void setScore(double score){
>		this.score=score;
>	}
>	public void getScore(){
>		return score;
>	}
>	public void pringScore(){
>		System.out.println("学生成绩："+score);
>	}
>}
>```

>[!FAQ] 什么是实体类？
> - 这个类中的变量都是私有，并且要对外提供相对应的get、set方法
>- 类中必须有一个公共的无参构造器

>[!FAQ] 实体类应用场景？
> - 数据和数据业务处理相分离
### 9.3.2 继承
>[!note] 继承
>- java中提供了一个关键字extends,使用这个关键字可以让一个类和另一个类建立起父类子类的关系
>- java是单继承的，java中的类不支持多继承，但支持多层继承
> ```Java
>public class B extends A{
>
>}
>```
>继承的特点
>- 子类能继承父类的非私有成员（成员变量、成员方法）
>
>继承后对象的创建
>- 子类的对象是由子类父类共同完成
>
>继承的好处
>- 减少重复代码的编写、提高了代码的复用性
>
>方法重写
>- 子类重写父类中的方法，要求方法名与父类中的一致
>- 子类访问父类成员变量使用super关键字
>- this关键字获取成员变量
>   
>子类构造器
>- 调用父类构造器后再执行子类构造器
>```Java
>class People{  //父类
>	private String name;
>	private int age;
>	public People(){
>	}
>	public People(String name,int age){
>		this.name=name;
>		this.age=age;
>	}
>	get和set方法---
>}
>
>class Teacher extends People{  //子类
>	private String skill;
>	public Teacher(){
>	}
>	public Teacher(String name,int age,String skill){
>		super(name,age);  //使用super关键字将参数传给父类构造器
>		this.skill=skill;
>	}
>	get和set方法---
>}
>```
### 9.3.3 多态
>[!note] 多态
>多态是继承/实现情况下的一种情况。表现为行为多态和对象多态。
>- 对象多态允许一个父类的引用指向不同子类的对象，并且调用子类的实现方法。
>-  行为多态更关注的是不同对象在相同上下文中表现出不同的行为。
>	- 父类
>	![[Pasted image 20240614155352.png|462]]
>	- 子类
>	 ![[Pasted image 20240614155525.png|475]]
>	![[Pasted image 20240614155539.png|475]]
>

>[!FAQ] 使用多态的好处？
>1.在多态形式下，右边对象解耦，易于扩展和维护
>2.在定义方法时，父类对象可以接受一切子类对象，扩展性更强
>3.多态下不能调用子类独有方法->可使用instanceof来判断对象类型然后进行强制转换
## 9.4 成员变量和局部变量
### 1.类中位置不同
- 成员变量（类中、方法外）
- 局部变量（常见于方法中）
### 2.初值不同
- 成员变量（有默认值、无需初始化值）
- 局部变量（无默认值、必须初始化值）
### 3. 作用域不同
- 成员变量：堆内存（和对象在一起）
- 局部变量：栈内存（和方法函数在一起）
### 4.生命周期不同
- 成员变量：与对象共生死（对象创建产生、对象结束消亡）
- 局部变量：与方法共生死（方法调用产生、方法结束消亡）
![[Pasted image 20240403182117.png|900]]
## 9.5 API
>[!note] ### Object类
>``` Java
public String toString()  //返回对象的字符串表示形式
public Boolean equals(Object o)  //判断两个对象是否相等 ==是比较对象地址 使用equals便于重写制定规则
protected Object clone()  //对象克隆
>```
>
>1. cloneable是标记接口
>2. 只有实现了cloneable接口才可以使用clone方法
>3. Objects equals方法有非空判断
>#### 浅拷贝
>- 拷贝出来的数据与原数据一致，拷贝的是地址
>#### 深拷贝
>- 拷贝出来的数据与原数据一致，创建新对象

>[!note] ### 包装类
>1. 包装类常见操作
>- 可以把基本数据类型转换为字符串类型
>```Java
>public static String toString(double d)
>public String toString()
>```
>- 可以把字符串类型的数值转换为数值本身对应的类型
>```Java
>public static int parseInt(String s)
>public static Integer valueOf(String s)
>```

>[!note] ### StringBuilder类
>1. StringBuilder类适用于拼接字符串，性能优于String直接拼接
>2. 字符串拼接少，使用String合适
>- StringBuffer和StringBuilder区别
>	- StringBuffer线程安全 StringBuilder线程不安全

>[!note] ### StringJoiner类
>与StringBuilder类似 也是操作字符串的类
>```Java
>StringJoiner s=new StringJoiner(分隔符，起始符，结束符)
>s.add(内容);
>return s.toString();返回字符串
>```

>[!note] ### Math类
>![[Pasted image 20250115201529.png|875]]

>[!note] ### System 类
>![[Pasted image 20250115201832.png|575]]
# 10.设计模式
## 13.1 单例模式
```Java
//饿汉式单例 获取类对象时，对象已经创建好了
public class A{
	//定义一个类变量记住类的一个对象
	private static A a=new A();
	//必须私有类的构造器
	private A(){
	
	}
	//定义一个类方法返回类对象
	public static A getObject(){
		return a;
	}
}
```

>[!note] 单例模式的应用场景和好处？
>Java Runtime 任务管理器 等 
>好处：避免浪费内存 确保一个类只有一个对象

```Java
//懒汉式单例模式 获取类对象后才创建对象
public class A{
	private static B b;
	private B(){
	
	}
	public static B getInstance(){
		if(b==null){
			b=new B();
		}
		return b;
	}
}
```

>[!FAQ] 饿汉VS懒汉？
>饿汉适用于频繁使用的对象 懒汉适用于偶尔使用的对象